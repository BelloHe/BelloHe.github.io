<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Hyjal's blog]]></title>
  <subtitle><![CDATA[on the way]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hyjal-binbin.com//"/>
  <updated>2015-10-22T02:54:44.177Z</updated>
  <id>http://hyjal-binbin.com//</id>
  
  <author>
    <name><![CDATA[Hyjal]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[捕获USB设备插入/拔出消息]]></title>
    <link href="http://hyjal-binbin.com/2015/10/22/USBMessage/"/>
    <id>http://hyjal-binbin.com/2015/10/22/USBMessage/</id>
    <published>2015-10-22T02:54:44.237Z</published>
    <updated>2015-10-22T02:54:44.177Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_需求">0x00 需求</h1><p>　　捕获USB设备插入/拔出消息</p>
<h1 id="0x01_WM_DEVICECHANGE">0x01 WM_DEVICECHANGE</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_需求">0x00 需求</h1><p>　　捕获USB设备插入/拔出消息</p>
<h1 id="0x01_WM_DEVICECHANGE">0x01 WM_DEVICECHANGE</h1>]]>
    </summary>
    
      <category term="Windows" scheme="http://hyjal-binbin.com/categories/Windows/"/>
    
      <category term="UBS" scheme="http://hyjal-binbin.com/categories/Windows/UBS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用acrobat SDK提取pdf文档内容]]></title>
    <link href="http://hyjal-binbin.com/2015/10/14/GetpdfContent/"/>
    <id>http://hyjal-binbin.com/2015/10/14/GetpdfContent/</id>
    <published>2015-10-13T16:00:00.000Z</published>
    <updated>2015-10-14T08:16:52.157Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_背景">0x00 背景</h1><p>　　HackingTeam泄漏事件影响颇大，415.77G的内容大多是邮件内容，分析起来比较麻烦，因而被大多数人忽略。网上有很多邮件分析的文章<a href="http://www.sec-un.org/analysis-on-the-hackingteam-mail-security-threat-intelligence-2.html" target="_blank" rel="external"><font color="blue">HT邮件分析</font></a>,主要是针对邮件关联进行分析，若对邮件内容进行分析则需提取邮件附件中的内容，再针对内容做进一步分析。本文背景其实与上文无关，只是借此提升逼格，下面将介绍如何利用acrobat SDK提取pdf文档内容。</p>
<h1 id="0x01_acrobat导入">0x01 acrobat导入</h1><p>　　只要安装了Adobe Acrobat，就能在其安装目录下找到acrobat.tlb，其中包含了adobe公司提供的接口,可对pdf进行各种操作<a href="http://partners.adobe.com/public/developer/en/acrobat/sdk/pdf/iac/IACOverview.pdf" target="_blank" rel="external"><font color="blue">参考文档</font></a>，使用类向导将其导入。<br>　　提取文本内容需导入CAcroApp、CAcroAVDoc、CAcroAVPageView、CAcroPDPage、CAcroPDTextSelect、CAcroHiliteList。<br><a id="more"></a></p>
<h1 id="0x02_提取文档内容">0x02 提取文档内容</h1><p>　　首先需要”打开”pdf，核心代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CAcroApp <span class="subst">*</span>pAcrpApp <span class="subst">=</span> <span class="literal">new</span> CAcroApp;</span><br><span class="line">COleException e;</span><br><span class="line">pAcrpApp<span class="subst">-&gt;</span>CreateDispatch(<span class="string">"AcroExch.App"</span>,<span class="subst">&amp;</span>e);</span><br><span class="line">CAcroAVDoc <span class="subst">*</span>pAvdoc <span class="subst">=</span> <span class="literal">new</span> CAcroAVDoc;</span><br><span class="line">pAvdoc<span class="subst">-&gt;</span>CreateDispatch(<span class="string">"AcroExch.AVDoc"</span>,<span class="subst">&amp;</span>e);</span><br><span class="line"><span class="comment">//打开pdf,其中PDFName为全路径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="subst">!</span>pAvdoc<span class="subst">-&gt;</span>Open(PDFName,<span class="built_in">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">	printf(<span class="string">"open pdf failed"</span>);</span><br><span class="line">	<span class="attribute">...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　打开文档后，通过pAvdoc可选择页数(默认为第一页)，创建高亮板(CAcroHiliteList),将选择页数的内容加入高亮板，然后就可以从中提取出该页的内容，核心代码如下：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CAcroAVPageView pageView;</span><br><span class="line">CAcroPDPage page;</span><br><span class="line">CAcroPDTextSelect<span class="built_in">*</span> textSelect = new CAcroPDTextSelect;</span><br><span class="line">CAcroHiliteList<span class="built_in">*</span> hilite = new CAcroHiliteList;</span><br><span class="line">long selectionSize;</span><br><span class="line">pageView.AttachDispatch<span class="params">(pAvdoc-&gt;GetAVPageView<span class="params">()</span>,TRUE)</span>;</span><br><span class="line">	</span><br><span class="line">hilite-&gt;CreateDispatch<span class="params">(<span class="string">"AcroExch.HiliteList"</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(hilite)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置为第一页</span></span><br><span class="line">	pageView.GoTo<span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	这里是设置高亮板的大小</span><br><span class="line">	由于没有找到如何在设置高亮板前获取该页内容长度的方法，所以采用设置成极大的长度</span><br><span class="line">	如有朋友知道方法，欢迎提出相互学习</span><br><span class="line">	*/</span></span><br><span class="line">	hilite-&gt;Add<span class="params">(<span class="number">0</span>,<span class="number">4000</span>)</span>;		</span><br><span class="line">	page.AttachDispatch<span class="params">(pageView.GetPage<span class="params">()</span>, TRUE)</span>;				</span><br><span class="line">	textSelect-&gt;AttachDispatch<span class="params">(page.CreateWordHilite<span class="params">(hilite-&gt;m_lpDispatch)</span>)</span>;</span><br><span class="line"></span><br><span class="line">	pAvdoc-&gt;SetTextSelection<span class="params">(textSelect-&gt;m_lpDispatch)</span>;</span><br><span class="line"></span><br><span class="line">	selectionSize = textSelect-&gt;GetNumText<span class="params">()</span>;		</span><br><span class="line">	<span class="keyword">if</span> <span class="params">(selectionSize &amp;&amp; strText.GetLength<span class="params">()</span> &lt; <span class="number">4000</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span><span class="params">(int i = <span class="number">0</span>;i &lt; selectionSize;i ++)</span></span><br><span class="line">		&#123;</span><br><span class="line">			strText += textSelect-&gt;GetText<span class="params">(i)</span>;</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　程序效果如下：</p>
<p><div align="center"><br><img src="/img/GetPDFConTent.png" alt="GetPDFConTent" align="center"><br></div><br>　　要完整提取出文档中的全部内容，可通过CAcroPDDoc获取pdf总页数，然后利用pageView.GoTo循环每一页，下面给出的完整工程将不包含此部分代码。<br><a href="http://download.csdn.net/detail/hyjal/9179615" target="_blank" rel="external"><font color="blue">完整工程下载</font></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_背景">0x00 背景</h1><p>　　HackingTeam泄漏事件影响颇大，415.77G的内容大多是邮件内容，分析起来比较麻烦，因而被大多数人忽略。网上有很多邮件分析的文章<a href="http://www.sec-un.org/analysis-on-the-hackingteam-mail-security-threat-intelligence-2.html"><font color = "blue">HT邮件分析</font></a>,主要是针对邮件关联进行分析，若对邮件内容进行分析则需提取邮件附件中的内容，再针对内容做进一步分析。本文背景其实与上文无关，只是借此提升逼格，下面将介绍如何利用acrobat SDK提取pdf文档内容。</p>
<h1 id="0x01_acrobat导入">0x01 acrobat导入</h1><p>　　只要安装了Adobe Acrobat，就能在其安装目录下找到acrobat.tlb，其中包含了adobe公司提供的接口,可对pdf进行各种操作<a href="http://partners.adobe.com/public/developer/en/acrobat/sdk/pdf/iac/IACOverview.pdf"><font color = "blue">参考文档</font></a>，使用类向导将其导入。<br>　　提取文本内容需导入CAcroApp、CAcroAVDoc、CAcroAVPageView、CAcroPDPage、CAcroPDTextSelect、CAcroHiliteList。<br>]]>
    
    </summary>
    
      <category term="Windows" scheme="http://hyjal-binbin.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[windows平台下获取USB设备“身份证”]]></title>
    <link href="http://hyjal-binbin.com/2015/10/07/device-CA/"/>
    <id>http://hyjal-binbin.com/2015/10/07/device-CA/</id>
    <published>2015-10-06T16:00:00.000Z</published>
    <updated>2015-10-14T07:29:48.148Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_写在前面">0x00 写在前面</h1><p>　　当我们将U盘插入windows主机时，会提示安装驱动，那么windows是如何判断应该安装哪个版本的驱动的呢？在这里将用到设备的身份信息，包括厂商、型号、序列号等。大概半年前做了一个关于设备检测的小工程，看了很多资料和帖子，将获取设备身份信息的方法在此记录，方便以后使用。</p>
<h1 id="0x01_USB设备有哪些身份信息">0x01 USB设备有哪些身份信息</h1><p>　　根据USB规范中的说明<a href="http://www.usb.org/developers/docs" target="_blank" rel="external"><font color="blue">USB规范官方文档</font></a>，供应商ID(VID)/产品识别码(PID)唯一标识一个设备，VID和PID都是两个字节长，其中，供应商ID（VID）由供应商向USB执行论坛申请，每个供应商的VID是唯一的，PID由供应商自行决定，理论上来说，不同的产品、相同产品的不同型号、相同型号的不同设计的产品最好采用不同的PID，以便区别相同厂家的不同设备。<a id="more"></a><br>　　在windows系统中，我们可以通过设备管理器-&gt;要查看的设备-&gt;属性-&gt;详细信息-&gt;硬件ID来查看VID/PID，如下图</p>
<p><div align="center"><br><img src="/img/hardwareID.png" width="414" height="430" alt="硬件ID" align="center"><br></div></p>
<h1 id="0x02_获取USB设备VID/PID">0x02 获取USB设备VID/PID</h1><p>　　下面将介绍枚举USB设备VID/PID的方法，后面会抽时间写一篇介绍如何通过U盘盘符获取U盘VID、PID的文章。<br>　　首先需要USB设备类GUID，设备管理器-&gt;通用串行总线控制器-&gt;随便选择一个设备-&gt;右键-&gt;属性-&gt;详细信息-&gt;设备类GUID，通用串行总线控制器的设备类GUID{36fc9e60-c465-11cf-8056-444553540000}。构造GUID，用SetupDiGetClassDevs获取设备信息结构的句柄，该结构包含了所有已安装USB设备。再调用SetupDiEnumDeviceInfo枚举设备实例，之后再调用SetupDiGetDeviceRegistryProperty即能获取硬件ID。核心代码如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">GUID USBGuid = &#123; <span class="number">0</span>x36fc9e60, <span class="number">0</span>xc465, <span class="number">0</span>x11cf, &#123; <span class="number">0</span>x80, <span class="number">0</span>x56, <span class="number">0</span>x44, <span class="number">0</span>x45, <span class="number">0</span>x53, <span class="number">0</span>x54, <span class="number">0</span>x00, <span class="number">0</span>x00&#125; &#125;;</span><br><span class="line">HDEVINFO hDevInfo = SetupDiGetClassDevs<span class="params">(&amp;USBGuid, NULL, NULL, DIGCF_PRESENT)</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> <span class="params">(int Device_Index = <span class="number">0</span>;; Device_Index++)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    BOOL bResualt = SetupDiEnumDeviceInfo<span class="params">(hDevInfo, Device_Index, &amp;tDevData)</span>;</span><br><span class="line">    ...</span><br><span class="line">    bResualt = SetupDiGetDeviceRegistryProperty<span class="params">(hDevInfo,</span><br><span class="line">			&amp;tDevData,</span><br><span class="line">			SPDRP_HARDWAREID,</span><br><span class="line">			NULL,</span><br><span class="line">			NULL,</span><br><span class="line">			<span class="number">0</span>,</span><br><span class="line">			&amp;RequiredSize)</span>;</span><br><span class="line">	<span class="keyword">if</span> <span class="params">(!bResualt)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="params">(GetLastError<span class="params">()</span> == ERROR_INSUFFICIENT_BUFFER)</span></span><br><span class="line">		&#123;</span><br><span class="line">			BYTE <span class="built_in">*</span>PropertBuffer = <span class="params">(BYTE*)</span>malloc<span class="params">(RequiredSize)</span>;</span><br><span class="line">			bResualt = SetupDiGetDeviceRegistryProperty<span class="params">(hDevInfo,</span><br><span class="line">				&amp;tDevData,</span><br><span class="line">				SPDRP_HARDWAREID,</span><br><span class="line">				NULL,</span><br><span class="line">				PropertBuffer,</span><br><span class="line">				RequiredSize,</span><br><span class="line">				NULL)</span>;</span><br><span class="line">			<span class="keyword">if</span> <span class="params">(bResualt)</span></span><br><span class="line">			&#123;</span><br><span class="line">				TCHAR <span class="built_in">*</span>HID = <span class="params">(TCHAR*)</span>PropertBuffer;</span><br><span class="line">				wprintf<span class="params">(L<span class="string">"%s \n"</span>, HID)</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">					free<span class="params">(PropertBuffer)</span>;</span><br><span class="line">					return FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行效果</p>
<p><div align="center"><br><img src="/img/enum.jpg" alt="Enum" align="center"><br></div><br><a href="http://download.csdn.net/detail/hyjal/9159365" target="_blank" rel="external"><font color="blue">完整工程下载</font></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_写在前面">0x00 写在前面</h1><p>　　当我们将U盘插入windows主机时，会提示安装驱动，那么windows是如何判断应该安装哪个版本的驱动的呢？在这里将用到设备的身份信息，包括厂商、型号、序列号等。大概半年前做了一个关于设备检测的小工程，看了很多资料和帖子，将获取设备身份信息的方法在此记录，方便以后使用。</p>
<h1 id="0x01_USB设备有哪些身份信息">0x01 USB设备有哪些身份信息</h1><p>　　根据USB规范中的说明<a href="http://www.usb.org/developers/docs"><font color = "blue">USB规范官方文档</font></a>，供应商ID(VID)/产品识别码(PID)唯一标识一个设备，VID和PID都是两个字节长，其中，供应商ID（VID）由供应商向USB执行论坛申请，每个供应商的VID是唯一的，PID由供应商自行决定，理论上来说，不同的产品、相同产品的不同型号、相同型号的不同设计的产品最好采用不同的PID，以便区别相同厂家的不同设备。]]>
    
    </summary>
    
      <category term="Windows" scheme="http://hyjal-binbin.com/categories/Windows/"/>
    
  </entry>
  
</feed>