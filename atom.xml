<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Hyjal's blog]]></title>
  <subtitle><![CDATA[on the way]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hyjal-binbin.com//"/>
  <updated>2016-04-14T08:45:40.043Z</updated>
  <id>http://hyjal-binbin.com//</id>
  
  <author>
    <name><![CDATA[Hyjal]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Python编码转换]]></title>
    <link href="http://hyjal-binbin.com/2016/03/24/decode/"/>
    <id>http://hyjal-binbin.com/2016/03/24/decode/</id>
    <published>2016-03-24T12:27:25.000Z</published>
    <updated>2016-04-14T08:45:40.043Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_概要">0x00 概要</h1><p>　　记录通过从linux传输文件到windows的辛酸历程。</p>
<h1 id="0x01_向ascii说不">0x01 向ascii说不</h1><p>　　ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。128个字符对于英文来说足够了，但对于中文来说是远远不够的。当接收文件名中包含中文的文件时，在创建文件的过程中易出现<font color="red">IOError: [Errno 22] invalid mode (‘r’) or filename</font>这样的错误。python 2.7 默认编码为ascii。<a id="more"></a>可以通过如图所示方式查看python默认编码</p>
<p><div align="center"><br><img src="/img/defaultencoding.png" alt="defaultencoding" align="center"><br></div><br>　　利用python从linux传输文件到windows第一步要做的就是设置默认编码为utf-8<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">default_encoding = <span class="string">'utf-8'</span></span><br><span class="line"><span class="keyword">if</span> sys.<span class="function"><span class="title">getdefaultencoding</span><span class="params">()</span></span> != default_encoding:</span><br><span class="line">    <span class="function"><span class="title">reload</span><span class="params">(sys)</span></span></span><br><span class="line">    sys.<span class="function"><span class="title">setdefaultencoding</span><span class="params">(default_encoding)</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="0x02_判断编码，进行编码转换">0x02 判断编码，进行编码转换</h1><p>　　判断编码推荐用chardet。chardet将给出为某种编码的可能性，代码如下：<br>‘’’<br>import chardet<br>print chardet.detect(XXX)<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　判断出编码类型后，对编码进行转换。</span><br></pre></td></tr></table></figure></p>
<h1 id="假设判断为utf8编码">假设判断为utf8编码</h1><p>strtmp = strXXX.decode(‘UTF-8’)<br>strXXX = strtmp.encode(‘GBK’)<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#0x02 <span class="keyword">decode</span>/<span class="keyword">encode</span>失败处理</span><br><span class="line">　　在程序使用过程中，出现了<span class="keyword">decode</span>/<span class="keyword">encode</span>错误的情况，网上搜索后判断应该是字符串中存在半/全角符号无法被识别的情况。强行解决方案如下：</span><br></pre></td></tr></table></figure></p>
<p>try:<br>　　strtmp = strXXX.decode(‘UTF-8’)<br>except:<br>　　strtmp = strXXX.decode(‘UTF-8’,’ignore’)<br>try:<br>　　strXXX = strtmp.encode(‘GBK’)<br>except:<br>　　strXXX = strtmp.encode(‘GBK’,’ignore’)<br>```<br>　　上面的方法虽然能在一定程度上解决问题，但不可靠，如有建议欢迎留言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_概要">0x00 概要</h1><p>　　记录通过从linux传输文件到windows的辛酸历程。</p>
<h1 id="0x01_向ascii说不">0x01 向ascii说不</h1><p>　　ASCII码一共规定了128个字符的编码，比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。128个字符对于英文来说足够了，但对于中文来说是远远不够的。当接收文件名中包含中文的文件时，在创建文件的过程中易出现<font color = "red">IOError: [Errno 22] invalid mode (‘r’) or filename</font>这样的错误。python 2.7 默认编码为ascii。]]>
    
    </summary>
    
      <category term="python" scheme="http://hyjal-binbin.com/tags/python/"/>
    
      <category term="编码" scheme="http://hyjal-binbin.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pandas库学习笔记]]></title>
    <link href="http://hyjal-binbin.com/2015/12/10/pandas/"/>
    <id>http://hyjal-binbin.com/2015/12/10/pandas/</id>
    <published>2015-12-09T16:00:00.000Z</published>
    <updated>2016-07-12T10:38:09.110Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_简单说明">0x00 简单说明</h1><p>　　作为机器学习小白，看了一段时间的coursera上Andrew Ng的视频，感觉还是难以入门，所以报名参加阿里天池上的比赛将理论和实践结合来提高姿势。题目是公交线路客流预测，所给的数据中并没有将乘客数量统计出来，需要自己对数据进行统计。先是自己写个python来统计分析数据(大概900M)，但跑了一晚上，发现太慢，在网上搜索到了pandas库，不到半个小时就统计完成。</p>
<h1 id="0x01_数据提取">0x01 数据提取</h1><p>　　pandas.read_csv可按照一定的格式打开txt、csv文件。read_csv可选参数很多，全部参数请看<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html?highlight=read_csv#pandas.read_csv" target="_blank" rel="external"><font color="blue">官方文档</font></a>，这里我只记录我觉得有用的和我用到的参数。<a id="more"></a><br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># filepath_or_buffer    数据文件的路径</span></span><br><span class="line"><span class="preprocessor"># sep                   数据的分割符号，不填则默认为','。阿里天池和kaggle的数据一般都是用','分割</span></span><br><span class="line"><span class="preprocessor"># header                每一列的列名，如果数据文件中有列名，则忽略，否则填None</span></span><br><span class="line"><span class="preprocessor"># names                 当header=None，names填入你要设置的列名</span></span><br><span class="line">e.g.</span><br><span class="line">df = pd.read_csv(<span class="string">"gd_train_data.txt"</span>,header=None,names = [<span class="string">'Use_city'</span>,<span class="string">'Line_name'</span>,<span class="string">'Terminal_id'</span>,<span class="string">'Card_id'</span>,<span class="string">'Create_city'</span>,<span class="string">'Deal_time'</span>,<span class="string">'Card_type'</span>])</span><br></pre></td></tr></table></figure></p>
<h1 id="0x02_数据分析与统计">0x02 数据分析与统计</h1><p>　　当数据比较大时，记事本或者notepad++等程序无法打开，pandas给出了几个函数可以快速进行数据分析与统计。</p>
<h2 id="df-head()"><font color="red">df.head()</font></h2><p>　　查看前5行数据</p>
<h2 id="df-describe()"><font color="red">df.describe()</font></h2><p>　　快速统计数据，可以方便我们观察数据的特性。describe有3个参数percentiles、include、exclude。percentliles可设置数据分层百分比，不填则默认为25%、50%、75%。include设置要统计的数据类型，默认为numeric dtypes，还有object dtypes、mixed dtypes可选。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e<span class="class">.g</span>.</span><br><span class="line">df.<span class="function"><span class="title">describe</span><span class="params">(include=[<span class="string">'O'</span>])</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="df[u’columns_name’]-value_counts()"><font color="red">df[u’columns name’].value_counts()</font></h2><p>　　统计设置的columns有哪些value，对应的value counts，返回的结构中包含index和value数组。index数组存放value，value数组存放value counts。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">e<span class="class">.g</span>.</span><br><span class="line">Card_type_table = df[u<span class="string">'Card_type'</span>].<span class="function"><span class="title">value_counts</span><span class="params">()</span></span> #统计卡片类型有哪几种，每种类型的卡片有多少张</span><br><span class="line"><span class="keyword">for</span> <span class="tag">i</span> <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">0</span>,len(Card_type_table.index)</span></span>):</span><br><span class="line">	<span class="keyword">if</span> Card_type_table<span class="class">.index</span>[i] == <span class="string">'卡片种类'</span>:</span><br><span class="line">		Num_Card_type_XXX == Card_type_table<span class="class">.values</span>[i]</span><br><span class="line">	elif ...</span><br><span class="line">	...</span><br></pre></td></tr></table></figure></p>
<h2 id="条件过滤"><font color="red">条件过滤</font></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e.g.</span><br><span class="line">df[df[<span class="string">u'Line_name'</span>]== Line_name)]  <span class="comment">#单个条件</span></span><br><span class="line">df[(df[<span class="string">u'Line_name'</span>]== Line_name ) &amp; (df[<span class="string">u'Deal_time'</span>] == Deal_time)]  <span class="comment">#多条件过滤用'&amp;'连接，并加上'()'</span></span><br></pre></td></tr></table></figure>
<h2 id="pd-Series()"><font color="red">pd.Series()</font></h2><p>　　添加列。两个参数，第一个参数为要添加的列数组，第二个参数为index。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">e</span>.<span class="keyword">g</span>.</span><br><span class="line"># 为df添加列<span class="string">'common'</span>,<span class="built_in">add</span>为要添加的列数组：<span class="built_in">add</span> = [<span class="string">''</span>,<span class="string">''</span>,<span class="string">''</span>,...]</span><br><span class="line">df = pd.read_csv(<span class="string">"gd_train_data.txt"</span>,header=None,names = [<span class="string">'Use_city'</span>,<span class="string">'Line_name'</span>,<span class="string">'Terminal_id'</span>,<span class="string">'Card_id'</span>,<span class="string">'Create_city'</span>,<span class="string">'Deal_time'</span>,<span class="string">'Card_type'</span>])</span><br><span class="line">df[<span class="string">'common'</span>] = pd.Series(<span class="built_in">add</span>,<span class="built_in">index</span> = df.<span class="built_in">index</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_简单说明">0x00 简单说明</h1><p>　　作为机器学习小白，看了一段时间的coursera上Andrew Ng的视频，感觉还是难以入门，所以报名参加阿里天池上的比赛将理论和实践结合来提高姿势。题目是公交线路客流预测，所给的数据中并没有将乘客数量统计出来，需要自己对数据进行统计。先是自己写个python来统计分析数据(大概900M)，但跑了一晚上，发现太慢，在网上搜索到了pandas库，不到半个小时就统计完成。</p>
<h1 id="0x01_数据提取">0x01 数据提取</h1><p>　　pandas.read_csv可按照一定的格式打开txt、csv文件。read_csv可选参数很多，全部参数请看<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.read_csv.html?highlight=read_csv#pandas.read_csv"><font color = "blue">官方文档</font></a>，这里我只记录我觉得有用的和我用到的参数。]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://hyjal-binbin.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[python urllib2学习]]></title>
    <link href="http://hyjal-binbin.com/2015/11/02/pythonweibo/"/>
    <id>http://hyjal-binbin.com/2015/11/02/pythonweibo/</id>
    <published>2015-11-02T09:20:53.785Z</published>
    <updated>2015-11-02T09:20:53.785Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_初探">0x00 初探</h1><p>　　提取百度主页html<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf8</span><br><span class="line">import urllib2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">    print urllib2.<span class="function"><span class="title">urlopen</span><span class="params">(url)</span></span>.<span class="function"><span class="title">read</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p><div align="center"><br><img src="/img/baidu.png" alt="baidu" align="center"><br></div></p>
<h1 id="0x01_cookie&amp;timeout">0x01 cookie&amp;timeout</h1><p>　　提取新浪微博“weibo.com/u/1000000002”出错，分析返回的html，请教同学后，猜测可能是没有加入cookie的原因用burpsuite拦截抓包，提取cookie:SUBP=0033W…….。也可用浏览器访问，保存cookie，然后提取。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf8</span><br><span class="line">import urllib2</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'http://weibo.com/u/1000000002'</span></span><br><span class="line">    rep = urllib2.<span class="function"><span class="title">Request</span><span class="params">(url)</span></span></span><br><span class="line">    rep.<span class="function"><span class="title">add_header</span><span class="params">(<span class="string">'cookie'</span>,<span class="string">'你的cookie'</span>)</span></span></span><br><span class="line">    print urllib2.<span class="function"><span class="title">urlopen</span><span class="params">(rep)</span></span>.<span class="function"><span class="title">read</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>　　遍历获取weibo信息时,会出现卡死在urlopen，加入timeout解决此问题<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print urllib2.<span class="function"><span class="title">urlopen</span><span class="params">(rep,timeout=<span class="number">10</span>)</span></span>.<span class="function"><span class="title">read</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>参考资料：<br><a href="http://zhuoqiang.me/python-urllib2-usage.html" target="_blank" rel="external"><font color="blue">Python 标准库 urllib2 的使用细节</font></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_初探">0x00 初探</h1><p>　　提取百度主页html<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</sp]]>
    </summary>
    
      <category term="python" scheme="http://hyjal-binbin.com/categories/python/"/>
    
      <category term="爬虫" scheme="http://hyjal-binbin.com/categories/python/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[捕获所有USB设备插入消息]]></title>
    <link href="http://hyjal-binbin.com/2015/10/28/USBMessage/"/>
    <id>http://hyjal-binbin.com/2015/10/28/USBMessage/</id>
    <published>2015-10-27T16:00:00.000Z</published>
    <updated>2015-10-30T08:13:41.188Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_说明">0x00 说明</h1><p>　　最先在网上copy的代码，能捕获U盘插入的消息，但不能捕获其他USB设备的消息，且无法获取U盘dbcc_name，多次询问度娘后终于找到正确的姿势，通过RegisterDeviceNotification注册DBT_DEVTYP_DEVICEINTERFACE，获取所有USB类设备的通知。</p>
<h1 id="0x01_WM_DEVICECHANGE">0x01 WM_DEVICECHANGE</h1><p>　　查询MSDN<a href="https://msdn.microsoft.com/en-us/library/aa363480(VS.85).aspx" target="_blank" rel="external"><font color="blue">[WM_DEVICECHANGE message]</font></a>,当设备或电脑的硬件配置发生改变时，会给每一个顶层窗口发通知，窗口通过WindowPro接收这个消息。WindowPro中的wParam参数告诉我们是具体是发生了什么事件，即设备或电脑的硬件配置发生了怎样的变化;lParam参数包含了一些设备具体的信息（wParam不同，对应的lParam也有一点的变化）。如果有U盘插入（这里为什么说是U盘而不是USB设备将会在后面进行说明），wParam=DBT_DEVICEARRIVAL,lParam中包含了U盘的盘符信息。<br>　　有了上述信息，我们可自己创建一个顶层窗口来接WM_DEVICECHANGE消息。首先定义一个WindowPro函数，当message参数为WM_DEVICECHANGE，wParam参数为DBT_DEVICEARRIVAL时，即表示有U盘插入。<br><a id="more"></a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LRESULT <span class="built_in">CALLBACK</span> UsbProc(HWND hwnd, <span class="built_in">UINT</span> message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (message)  </span><br><span class="line">	&#123;  	</span><br><span class="line">	<span class="keyword">case</span> WM_DEVICECHANGE:  </span><br><span class="line">		<span class="keyword">if</span>(wParam == DBT_DEVICEARRIVAL) <span class="comment">//设备激活  </span></span><br><span class="line">		&#123;  </span><br><span class="line">			PDEV_BROAD<span class="built_in">CAST_HDR</span> lpdb = (PDEV_BROAD<span class="built_in">CAST_HDR</span>)lParam;  </span><br><span class="line">			DEV_BROAD<span class="built_in">CAST_HDR</span>* pHdr = (DEV_BROAD<span class="built_in">CAST_HDR</span>*)lParam;</span><br><span class="line">			PDEV_BROAD<span class="built_in">CAST_VOLUME</span> lpdbv = (PDEV_BROAD<span class="built_in">CAST_VOLUME</span>)lpdb;  </span><br><span class="line">			PDEV_BROAD<span class="built_in">CAST_DEVICEINTERFACE</span> pdinfo = (PDEV_BROAD<span class="built_in">CAST_DEVICEINTERFACE</span>)pHdr;</span><br><span class="line">			<span class="comment">//pdinfo-&gt;dbcc_name</span></span><br><span class="line">			TCHAR szMsg[<span class="number">80</span>],Disk;</span><br><span class="line">			Disk = FirstDriveFromMask(lpdbv -&gt;dbcv_unitmask);</span><br><span class="line">			wsprintf (szMsg, L<span class="string">"Drive %c: Media has arrived./n"</span>,Disk);  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">break</span>;  </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　定义个一个窗口类，将窗口的处理函数定义为UsbProc。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASS     wndclass ;</span><br><span class="line"></span><br><span class="line">wndclass<span class="variable">.style</span>         = CS_HREDRAW | CS_VREDRAW ;<span class="comment">// 窗口类型</span></span><br><span class="line">wndclass<span class="variable">.lpfnWndProc</span>   = UsbProc ;<span class="comment">//窗口处理函数</span></span><br><span class="line">wndclass<span class="variable">.cbClsExtra</span>    = <span class="number">0</span> ;<span class="comment">//窗口扩展</span></span><br><span class="line">wndclass<span class="variable">.cbWndExtra</span>    = <span class="number">0</span> ;<span class="comment">//窗口实例扩展</span></span><br><span class="line">wndclass<span class="variable">.hInstance</span>     = hModule ;<span class="comment">//实例句柄</span></span><br><span class="line">wndclass<span class="variable">.hIcon</span>         = LoadIcon (<span class="literal">NULL</span>, IDI_APPLI<span class="built_in">CATION</span>) ;<span class="comment">//窗口的最小化图标</span></span><br><span class="line">wndclass<span class="variable">.hCursor</span>       = LoadCursor (<span class="literal">NULL</span>, IDC_ARROW) ;<span class="comment">//窗口鼠标光标</span></span><br><span class="line">wndclass<span class="variable">.hbrBackground</span> = (HBRUSH) GetStockObject (WHITE_BRUSH) ;<span class="comment">//窗口背景色</span></span><br><span class="line">wndclass<span class="variable">.lpszMenuName</span>  = <span class="literal">NULL</span> ;<span class="comment">//窗口菜单</span></span><br><span class="line">wndclass<span class="variable">.lpszClassName</span> = szAppName ;<span class="comment">// 窗口类名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建自定义的窗口类时，在使用该窗口类前必须注册该窗口类</span></span><br><span class="line"><span class="keyword">if</span> (!RegisterClass (&amp;wndclass))</span><br><span class="line">&#123;</span><br><span class="line">	MessageBox (<span class="literal">NULL</span>, TEXT (<span class="string">"This program requires Windows NT!"</span>), </span><br><span class="line">		szAppName, MB_ICONERROR) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口用来接收消息</span></span><br><span class="line">hwnd = CreateWindow (szAppName,                  <span class="comment">// window class name</span></span><br><span class="line">	TEXT (<span class="string">"The Hello Program"</span>), <span class="comment">// window caption</span></span><br><span class="line">	WS_OVERLAPPEDWINDOW,        <span class="comment">// window style</span></span><br><span class="line">	CW_USEDEFAULT,              <span class="comment">// initial x position</span></span><br><span class="line">	CW_USEDEFAULT,              <span class="comment">// initial y position</span></span><br><span class="line">	CW_USEDEFAULT,              <span class="comment">// initial x size</span></span><br><span class="line">	CW_USEDEFAULT,              <span class="comment">// initial y size</span></span><br><span class="line">	<span class="literal">NULL</span>,                       <span class="comment">// parent window handle</span></span><br><span class="line">	<span class="literal">NULL</span>,                       <span class="comment">// window menu handle</span></span><br><span class="line">	hModule,                  <span class="comment">// program instance handle</span></span><br><span class="line">	<span class="literal">NULL</span>);                  <span class="comment">// creation parameters</span></span><br></pre></td></tr></table></figure></p>
<h1 id="0x03_Register_DBT_DEVTYP_DEVICEINTERFACE">0x03 Register DBT_DEVTYP_DEVICEINTERFACE</h1><p>　　通过上面的代码，能够捕获U盘插入的消息，但却无法捕获到其他类型的USB设备。经过调试，发现只有当pHdr-&gt;dbch_devicetype=DBT_DEVTYP_VOLUME时，才会接收到通知。所以上面的代码中用PDEV_BROADCAST_DEVICEINTERFACE结构去格式化lParam就会得到错误的dbcc_classguid和dbcc_name,而用PDEV_BROADCAST_VOLUME则可以获取正确的盘符信息（dbcv_unitmask）。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _DEV_BROADCAST_HDR &#123;</span><br><span class="line">  DWORD dbch_size<span class="comment">;</span></span><br><span class="line">  DWORD dbch_devicetype<span class="comment">;</span></span><br><span class="line">  DWORD dbch_reserved<span class="comment">;</span></span><br><span class="line">&#125; DEV_BROADCAST_HDR, *PDEV_BROADCAST_HDR<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">typedef struct _DEV_BROADCAST_VOLUME &#123;</span><br><span class="line">  DWORD dbcv_size<span class="comment">;</span></span><br><span class="line">  DWORD dbcv_devicetype<span class="comment">;</span></span><br><span class="line">  DWORD dbcv_reserved<span class="comment">;</span></span><br><span class="line">  DWORD dbcv_unitmask<span class="comment">;</span></span><br><span class="line">  WORD  dbcv_flags<span class="comment">;</span></span><br><span class="line">&#125; DEV_BROADCAST_VOLUME, *PDEV_BROADCAST_VOLUME<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">typedef struct _DEV_BROADCAST_DEVICEINTERFACE &#123;</span><br><span class="line">  DWORD dbcc_size<span class="comment">;</span></span><br><span class="line">  DWORD dbcc_devicetype<span class="comment">;</span></span><br><span class="line">  DWORD dbcc_reserved<span class="comment">;</span></span><br><span class="line">  GUID  dbcc_classguid<span class="comment">;</span></span><br><span class="line">  TCHAR dbcc_name[1]<span class="comment">;</span></span><br><span class="line">&#125; DEV_BROADCAST_DEVICEINTERFACE, *PDEV_BROADCAST_DEVICEINTERFACE<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>　　MSDN<a href="https://msdn.microsoft.com/EN-US/library/windows/desktop/aa363431.aspx" target="_blank" rel="external"><font color="blue">[RegisterDeviceNotification]</font></a>中Remarks部分说明了顶层窗口会收到basic notification，其中就包括了DBT_DEVTYP_VOLUME和DBT_DEVTYP_PORT，其他类型的通知则需要通过RegisterDeviceNotification来注册。RegisterDeviceNotification中第二个参数填入DEV_BROADCAST_DEVICEINTERFACE结构，dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE、dbcc_classguid = GUID_DEVINTERFACE_USB_DEVICE,也可以根据需要换成他<a href="http://blog.csdn.net/jhqin/article/details/6775321" target="_blank" rel="external"><font color="blue">常用设备接口类GUID</font></a>。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">#define DBT_DEVTYP_OEM                  <span class="number">0x00000000</span>  // oem-defined device type</span><br><span class="line">#define DBT_DEVTYP_DEVNODE              <span class="number">0x00000001</span>  // devnode number</span><br><span class="line">#define DBT_DEVTYP_VOLUME               <span class="number">0x00000002</span>  // logical volume</span><br><span class="line">#define DBT_DEVTYP_PORT                 <span class="number">0x00000003</span>  // serial, parallel</span><br><span class="line">#define DBT_DEVTYP_NET                  <span class="number">0x00000004</span>  // network resource</span><br><span class="line"></span><br><span class="line">#if(WINVER &gt;= 0x040A)</span><br><span class="line">#define DBT_DEVTYP_DEVICEINTERFACE      <span class="number">0x00000005</span>  // device interface class</span><br><span class="line">#define DBT_DEVTYP_HANDLE               <span class="number">0x00000006</span>  // file system handle</span><br><span class="line"></span><br><span class="line">#if(WINVER &gt;= _WIN32_WINNT_WIN7)</span><br><span class="line">#define DBT_DEVTYP_DEVINST              <span class="number">0x00000007</span>  // device instance</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">DEV_BROADCAST_DEVICEINTERFACE NotificationFilter<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">ZeroMemory(&amp;NotificationFilter, sizeof(NotificationFilter))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">NotificationFilter.dbcc_size = sizeof(NotificationFilter)<span class="comment">;</span></span><br><span class="line">NotificationFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE<span class="comment">;</span></span><br><span class="line">NotificationFilter.dbcc_reserved = 0<span class="comment">;</span></span><br><span class="line">NotificationFilter.dbcc_classguid = GUID_DEVINTERFACE_USB_DEVICE<span class="comment">;</span></span><br><span class="line">HDEVNOTIFY hDevNotify = RegisterDeviceNotification(hwnd, &amp;NotificationFilter, DEVICE_NOTIFY_WINDOW_HANDLE)<span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">UnregisterDeviceNotification(hDevNotify)<span class="comment">;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>　　修改WindowPro函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK UsbProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (message)  </span><br><span class="line">	&#123;  	</span><br><span class="line">	<span class="keyword">case</span> WM_DEVICECHANGE:  </span><br><span class="line">		<span class="keyword">if</span>(wParam == DBT_DEVICEARRIVAL) <span class="comment">//设备激活  </span></span><br><span class="line">		&#123;  </span><br><span class="line">			PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;</span><br><span class="line">			<span class="keyword">if</span> (lpdb-&gt;dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) </span><br><span class="line">			&#123;</span><br><span class="line">				DEV_BROADCAST_HDR* pHdr = (DEV_BROADCAST_HDR*)lParam;</span><br><span class="line">				PDEV_BROADCAST_DEVICEINTERFACE pdinfo = (PDEV_BROADCAST_DEVICEINTERFACE)pHdr;</span><br><span class="line">				printf(<span class="string">"GUID:%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"</span>,pdinfo-&gt;dbcc_classguid.Data1,pdinfo-&gt;dbcc_classguid.Data2,pdinfo-&gt;dbcc_classguid.Data3,pdinfo-&gt;dbcc_classguid.Data4[<span class="number">0</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">1</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">2</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">3</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">4</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">5</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">6</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">7</span>]);</span><br><span class="line">				printf(<span class="string">"dbcc_name:%s"</span>,pdinfo-&gt;dbcc_name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">break</span>;  </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考资料<br><a href="http://bbs.csdn.net/topics/390158016" target="_blank" rel="external"><font color="blue">CSDN-关于u盘识别（OnDeviceChange方式）的几个问题，请教！</font></a><br><a href="http://blog.sina.com.cn/s/blog_9ffb29e101018sug.html" target="_blank" rel="external"><font color="blue">新浪博客-利用服务获取USB设备插拨事件以及获取设备硬件信息</font></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_说明">0x00 说明</h1><p>　　最先在网上copy的代码，能捕获U盘插入的消息，但不能捕获其他USB设备的消息，且无法获取U盘dbcc_name，多次询问度娘后终于找到正确的姿势，通过RegisterDeviceNotification注册DBT_DEVTYP_DEVICEINTERFACE，获取所有USB类设备的通知。</p>
<h1 id="0x01_WM_DEVICECHANGE">0x01 WM_DEVICECHANGE</h1><p>　　查询MSDN<a href="https://msdn.microsoft.com/en-us/library/aa363480(VS.85).aspx"><font color="blue">[WM_DEVICECHANGE message]</font></a>,当设备或电脑的硬件配置发生改变时，会给每一个顶层窗口发通知，窗口通过WindowPro接收这个消息。WindowPro中的wParam参数告诉我们是具体是发生了什么事件，即设备或电脑的硬件配置发生了怎样的变化;lParam参数包含了一些设备具体的信息（wParam不同，对应的lParam也有一点的变化）。如果有U盘插入（这里为什么说是U盘而不是USB设备将会在后面进行说明），wParam=DBT_DEVICEARRIVAL,lParam中包含了U盘的盘符信息。<br>　　有了上述信息，我们可自己创建一个顶层窗口来接WM_DEVICECHANGE消息。首先定义一个WindowPro函数，当message参数为WM_DEVICECHANGE，wParam参数为DBT_DEVICEARRIVAL时，即表示有U盘插入。<br>]]>
    
    </summary>
    
      <category term="Windows" scheme="http://hyjal-binbin.com/categories/Windows/"/>
    
      <category term="USB" scheme="http://hyjal-binbin.com/categories/Windows/USB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用acrobat SDK提取pdf文档内容]]></title>
    <link href="http://hyjal-binbin.com/2015/10/14/GetpdfContent/"/>
    <id>http://hyjal-binbin.com/2015/10/14/GetpdfContent/</id>
    <published>2015-10-13T16:00:00.000Z</published>
    <updated>2015-10-14T08:16:52.157Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_背景">0x00 背景</h1><p>　　HackingTeam泄漏事件影响颇大，415.77G的内容大多是邮件内容，分析起来比较麻烦，因而被大多数人忽略。网上有很多邮件分析的文章<a href="http://www.sec-un.org/analysis-on-the-hackingteam-mail-security-threat-intelligence-2.html" target="_blank" rel="external"><font color="blue">HT邮件分析</font></a>,主要是针对邮件关联进行分析，若对邮件内容进行分析则需提取邮件附件中的内容，再针对内容做进一步分析。本文背景其实与上文无关，只是借此提升逼格，下面将介绍如何利用acrobat SDK提取pdf文档内容。</p>
<h1 id="0x01_acrobat导入">0x01 acrobat导入</h1><p>　　只要安装了Adobe Acrobat，就能在其安装目录下找到acrobat.tlb，其中包含了adobe公司提供的接口,可对pdf进行各种操作<a href="http://partners.adobe.com/public/developer/en/acrobat/sdk/pdf/iac/IACOverview.pdf" target="_blank" rel="external"><font color="blue">参考文档</font></a>，使用类向导将其导入。<br>　　提取文本内容需导入CAcroApp、CAcroAVDoc、CAcroAVPageView、CAcroPDPage、CAcroPDTextSelect、CAcroHiliteList。<br><a id="more"></a></p>
<h1 id="0x02_提取文档内容">0x02 提取文档内容</h1><p>　　首先需要”打开”pdf，核心代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CAcroApp <span class="subst">*</span>pAcrpApp <span class="subst">=</span> <span class="literal">new</span> CAcroApp;</span><br><span class="line">COleException e;</span><br><span class="line">pAcrpApp<span class="subst">-&gt;</span>CreateDispatch(<span class="string">"AcroExch.App"</span>,<span class="subst">&amp;</span>e);</span><br><span class="line">CAcroAVDoc <span class="subst">*</span>pAvdoc <span class="subst">=</span> <span class="literal">new</span> CAcroAVDoc;</span><br><span class="line">pAvdoc<span class="subst">-&gt;</span>CreateDispatch(<span class="string">"AcroExch.AVDoc"</span>,<span class="subst">&amp;</span>e);</span><br><span class="line"><span class="comment">//打开pdf,其中PDFName为全路径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="subst">!</span>pAvdoc<span class="subst">-&gt;</span>Open(PDFName,<span class="built_in">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">	printf(<span class="string">"open pdf failed"</span>);</span><br><span class="line">	<span class="attribute">...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　打开文档后，通过pAvdoc可选择页数(默认为第一页)，创建高亮板(CAcroHiliteList),将选择页数的内容加入高亮板，然后就可以从中提取出该页的内容，核心代码如下：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CAcroAVPageView pageView;</span><br><span class="line">CAcroPDPage page;</span><br><span class="line">CAcroPDTextSelect<span class="built_in">*</span> textSelect = new CAcroPDTextSelect;</span><br><span class="line">CAcroHiliteList<span class="built_in">*</span> hilite = new CAcroHiliteList;</span><br><span class="line">long selectionSize;</span><br><span class="line">pageView.AttachDispatch<span class="params">(pAvdoc-&gt;GetAVPageView<span class="params">()</span>,TRUE)</span>;</span><br><span class="line">	</span><br><span class="line">hilite-&gt;CreateDispatch<span class="params">(<span class="string">"AcroExch.HiliteList"</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(hilite)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置为第一页</span></span><br><span class="line">	pageView.GoTo<span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	这里是设置高亮板的大小</span><br><span class="line">	由于没有找到如何在设置高亮板前获取该页内容长度的方法，所以采用设置成极大的长度</span><br><span class="line">	如有朋友知道方法，欢迎提出相互学习</span><br><span class="line">	*/</span></span><br><span class="line">	hilite-&gt;Add<span class="params">(<span class="number">0</span>,<span class="number">4000</span>)</span>;		</span><br><span class="line">	page.AttachDispatch<span class="params">(pageView.GetPage<span class="params">()</span>, TRUE)</span>;				</span><br><span class="line">	textSelect-&gt;AttachDispatch<span class="params">(page.CreateWordHilite<span class="params">(hilite-&gt;m_lpDispatch)</span>)</span>;</span><br><span class="line"></span><br><span class="line">	pAvdoc-&gt;SetTextSelection<span class="params">(textSelect-&gt;m_lpDispatch)</span>;</span><br><span class="line"></span><br><span class="line">	selectionSize = textSelect-&gt;GetNumText<span class="params">()</span>;		</span><br><span class="line">	<span class="keyword">if</span> <span class="params">(selectionSize &amp;&amp; strText.GetLength<span class="params">()</span> &lt; <span class="number">4000</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span><span class="params">(int i = <span class="number">0</span>;i &lt; selectionSize;i ++)</span></span><br><span class="line">		&#123;</span><br><span class="line">			strText += textSelect-&gt;GetText<span class="params">(i)</span>;</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　程序效果如下：</p>
<p><div align="center"><br><img src="/img/GetPDFConTent.png" alt="GetPDFConTent" align="center"><br></div><br>　　要完整提取出文档中的全部内容，可通过CAcroPDDoc获取pdf总页数，然后利用pageView.GoTo循环每一页，下面给出的完整工程将不包含此部分代码。<br><a href="http://download.csdn.net/detail/hyjal/9179615" target="_blank" rel="external"><font color="blue">完整工程下载</font></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_背景">0x00 背景</h1><p>　　HackingTeam泄漏事件影响颇大，415.77G的内容大多是邮件内容，分析起来比较麻烦，因而被大多数人忽略。网上有很多邮件分析的文章<a href="http://www.sec-un.org/analysis-on-the-hackingteam-mail-security-threat-intelligence-2.html"><font color = "blue">HT邮件分析</font></a>,主要是针对邮件关联进行分析，若对邮件内容进行分析则需提取邮件附件中的内容，再针对内容做进一步分析。本文背景其实与上文无关，只是借此提升逼格，下面将介绍如何利用acrobat SDK提取pdf文档内容。</p>
<h1 id="0x01_acrobat导入">0x01 acrobat导入</h1><p>　　只要安装了Adobe Acrobat，就能在其安装目录下找到acrobat.tlb，其中包含了adobe公司提供的接口,可对pdf进行各种操作<a href="http://partners.adobe.com/public/developer/en/acrobat/sdk/pdf/iac/IACOverview.pdf"><font color = "blue">参考文档</font></a>，使用类向导将其导入。<br>　　提取文本内容需导入CAcroApp、CAcroAVDoc、CAcroAVPageView、CAcroPDPage、CAcroPDTextSelect、CAcroHiliteList。<br>]]>
    
    </summary>
    
      <category term="Windows" scheme="http://hyjal-binbin.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[windows平台下获取USB设备“身份证”]]></title>
    <link href="http://hyjal-binbin.com/2015/10/07/device-CA/"/>
    <id>http://hyjal-binbin.com/2015/10/07/device-CA/</id>
    <published>2015-10-06T16:00:00.000Z</published>
    <updated>2015-10-22T03:13:30.149Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_写在前面">0x00 写在前面</h1><p>　　当我们将U盘插入windows主机时，会提示安装驱动，那么windows是如何判断应该安装哪个版本的驱动的呢？在这里将用到设备的身份信息，包括厂商、型号、序列号等。大概半年前做了一个关于设备检测的小工程，看了很多资料和帖子，将获取设备身份信息的方法在此记录，方便以后使用。</p>
<h1 id="0x01_USB设备有哪些身份信息">0x01 USB设备有哪些身份信息</h1><p>　　根据USB规范中的说明<a href="http://www.usb.org/developers/docs" target="_blank" rel="external"><font color="blue">USB规范官方文档</font></a>，供应商ID(VID)/产品识别码(PID)唯一标识一个设备，VID和PID都是两个字节长，其中，供应商ID（VID）由供应商向USB执行论坛申请，每个供应商的VID是唯一的，PID由供应商自行决定，理论上来说，不同的产品、相同产品的不同型号、相同型号的不同设计的产品最好采用不同的PID，以便区别相同厂家的不同设备。<a id="more"></a><br>　　在windows系统中，我们可以通过设备管理器-&gt;要查看的设备-&gt;属性-&gt;详细信息-&gt;硬件ID来查看VID/PID，如下图</p>
<p><div align="center"><br><img src="/img/hardwareID.png" width="414" height="430" alt="硬件ID" align="center"><br></div></p>
<h1 id="0x02_获取USB设备VID/PID">0x02 获取USB设备VID/PID</h1><p>　　下面将介绍枚举USB设备VID/PID的方法，后面会抽时间写一篇介绍如何通过U盘盘符获取U盘VID、PID的文章。<br>　　首先需要USB设备类GUID，设备管理器-&gt;通用串行总线控制器-&gt;随便选择一个设备-&gt;右键-&gt;属性-&gt;详细信息-&gt;设备类GUID，通用串行总线控制器的设备类GUID{36fc9e60-c465-11cf-8056-444553540000}。构造GUID，用SetupDiGetClassDevs获取设备信息结构的句柄，该结构包含了所有已安装USB设备。再调用SetupDiEnumDeviceInfo枚举设备实例，之后再调用SetupDiGetDeviceRegistryProperty即能获取硬件ID。核心代码如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">GUID USBGuid = &#123; <span class="number">0</span>x36fc9e60, <span class="number">0</span>xc465, <span class="number">0</span>x11cf, &#123; <span class="number">0</span>x80, <span class="number">0</span>x56, <span class="number">0</span>x44, <span class="number">0</span>x45, <span class="number">0</span>x53, <span class="number">0</span>x54, <span class="number">0</span>x00, <span class="number">0</span>x00&#125; &#125;;</span><br><span class="line">HDEVINFO hDevInfo = SetupDiGetClassDevs<span class="params">(&amp;USBGuid, NULL, NULL, DIGCF_PRESENT)</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> <span class="params">(int Device_Index = <span class="number">0</span>;; Device_Index++)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    BOOL bResualt = SetupDiEnumDeviceInfo<span class="params">(hDevInfo, Device_Index, &amp;tDevData)</span>;</span><br><span class="line">    ...</span><br><span class="line">    bResualt = SetupDiGetDeviceRegistryProperty<span class="params">(hDevInfo,</span><br><span class="line">			&amp;tDevData,</span><br><span class="line">			SPDRP_HARDWAREID,</span><br><span class="line">			NULL,</span><br><span class="line">			NULL,</span><br><span class="line">			<span class="number">0</span>,</span><br><span class="line">			&amp;RequiredSize)</span>;</span><br><span class="line">	<span class="keyword">if</span> <span class="params">(!bResualt)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="params">(GetLastError<span class="params">()</span> == ERROR_INSUFFICIENT_BUFFER)</span></span><br><span class="line">		&#123;</span><br><span class="line">			BYTE <span class="built_in">*</span>PropertBuffer = <span class="params">(BYTE*)</span>malloc<span class="params">(RequiredSize)</span>;</span><br><span class="line">			bResualt = SetupDiGetDeviceRegistryProperty<span class="params">(hDevInfo,</span><br><span class="line">				&amp;tDevData,</span><br><span class="line">				SPDRP_HARDWAREID,</span><br><span class="line">				NULL,</span><br><span class="line">				PropertBuffer,</span><br><span class="line">				RequiredSize,</span><br><span class="line">				NULL)</span>;</span><br><span class="line">			<span class="keyword">if</span> <span class="params">(bResualt)</span></span><br><span class="line">			&#123;</span><br><span class="line">				TCHAR <span class="built_in">*</span>HID = <span class="params">(TCHAR*)</span>PropertBuffer;</span><br><span class="line">				wprintf<span class="params">(L<span class="string">"%s \n"</span>, HID)</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">					free<span class="params">(PropertBuffer)</span>;</span><br><span class="line">					return FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行效果</p>
<p><div align="center"><br><img src="/img/enum.jpg" alt="Enum" align="center"><br></div><br><a href="http://download.csdn.net/detail/hyjal/9159365" target="_blank" rel="external"><font color="blue">完整工程下载</font></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_写在前面">0x00 写在前面</h1><p>　　当我们将U盘插入windows主机时，会提示安装驱动，那么windows是如何判断应该安装哪个版本的驱动的呢？在这里将用到设备的身份信息，包括厂商、型号、序列号等。大概半年前做了一个关于设备检测的小工程，看了很多资料和帖子，将获取设备身份信息的方法在此记录，方便以后使用。</p>
<h1 id="0x01_USB设备有哪些身份信息">0x01 USB设备有哪些身份信息</h1><p>　　根据USB规范中的说明<a href="http://www.usb.org/developers/docs"><font color = "blue">USB规范官方文档</font></a>，供应商ID(VID)/产品识别码(PID)唯一标识一个设备，VID和PID都是两个字节长，其中，供应商ID（VID）由供应商向USB执行论坛申请，每个供应商的VID是唯一的，PID由供应商自行决定，理论上来说，不同的产品、相同产品的不同型号、相同型号的不同设计的产品最好采用不同的PID，以便区别相同厂家的不同设备。]]>
    
    </summary>
    
      <category term="Windows" scheme="http://hyjal-binbin.com/categories/Windows/"/>
    
      <category term="USB" scheme="http://hyjal-binbin.com/categories/Windows/USB/"/>
    
  </entry>
  
</feed>