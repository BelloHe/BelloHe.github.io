<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Hyjal's blog]]></title>
  <subtitle><![CDATA[on the way]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hyjal-binbin.com//"/>
  <updated>2015-10-30T08:01:32.198Z</updated>
  <id>http://hyjal-binbin.com//</id>
  
  <author>
    <name><![CDATA[Hyjal]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[捕获所有USB设备插入消息]]></title>
    <link href="http://hyjal-binbin.com/2015/10/28/USBMessage/"/>
    <id>http://hyjal-binbin.com/2015/10/28/USBMessage/</id>
    <published>2015-10-27T16:00:00.000Z</published>
    <updated>2015-10-30T08:01:32.198Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_说明">0x00 说明</h1><p>　　最先在网上copy的代码，能捕获U盘插入的消息，但不能捕获其他USB设备的消息，且无法获取U盘dbcc_name，多次询问度娘后终于找到正确的姿势，通过RegisterDeviceNotification注册DBT_DEVTYP_DEVICEINTERFACE，获取所有USB类设备的通知。</p>
<h1 id="0x01_WM_DEVICECHANGE">0x01 WM_DEVICECHANGE</h1><p>　　查询MSDN<a href="https://msdn.microsoft.com/en-us/library/aa363480(VS.85).aspx" target="_blank" rel="external"><font color="blue">[WM_DEVICECHANGE message]</font></a>,当设备或电脑的硬件配置发生改变时，会给每一个顶层窗口发通知，窗口通过WindowPro接收这个消息。WindowPro中的wParam参数告诉我们是具体是发生了什么事件，即设备或电脑的硬件配置发生了怎样的变化;lParam参数包含了一些设备具体的信息（wParam不同，对应的lParam也有一点的变化）。如果有U盘插入（这里为什么说是U盘而不是USB设备将会在后面进行说明），wParam=DBT_DEVICEARRIVAL,lParam中包含了U盘的盘符信息。<br>　　有了上述信息，我们可自己创建一个顶层窗口来接WM_DEVICECHANGE消息。首先定义一个WindowPro函数，当message参数为WM_DEVICECHANGE，wParam参数为DBT_DEVICEARRIVAL时，即表示有U盘插入。<br><a id="more"></a><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LRESULT <span class="built_in">CALLBACK</span> UsbProc(HWND hwnd, <span class="built_in">UINT</span> message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (message)  </span><br><span class="line">	&#123;  	</span><br><span class="line">	<span class="keyword">case</span> WM_DEVICECHANGE:  </span><br><span class="line">		<span class="keyword">if</span>(wParam == DBT_DEVICEARRIVAL) <span class="comment">//设备激活  </span></span><br><span class="line">		&#123;  </span><br><span class="line">			PDEV_BROAD<span class="built_in">CAST_HDR</span> lpdb = (PDEV_BROAD<span class="built_in">CAST_HDR</span>)lParam;  </span><br><span class="line">			DEV_BROAD<span class="built_in">CAST_HDR</span>* pHdr = (DEV_BROAD<span class="built_in">CAST_HDR</span>*)lParam;</span><br><span class="line">			PDEV_BROAD<span class="built_in">CAST_VOLUME</span> lpdbv = (PDEV_BROAD<span class="built_in">CAST_VOLUME</span>)lpdb;  </span><br><span class="line">			PDEV_BROAD<span class="built_in">CAST_DEVICEINTERFACE</span> pdinfo = (PDEV_BROAD<span class="built_in">CAST_DEVICEINTERFACE</span>)pHdr;</span><br><span class="line">			<span class="comment">//pdinfo-&gt;dbcc_name</span></span><br><span class="line">			TCHAR szMsg[<span class="number">80</span>],Disk;</span><br><span class="line">			Disk = FirstDriveFromMask(lpdbv -&gt;dbcv_unitmask);</span><br><span class="line">			wsprintf (szMsg, L<span class="string">"Drive %c: Media has arrived./n"</span>,Disk);  </span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">break</span>;  </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　定义个一个窗口类，将窗口的处理函数定义为UsbProc。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASS     wndclass ;</span><br><span class="line"></span><br><span class="line">wndclass<span class="variable">.style</span>         = CS_HREDRAW | CS_VREDRAW ;<span class="comment">// 窗口类型</span></span><br><span class="line">wndclass<span class="variable">.lpfnWndProc</span>   = UsbProc ;<span class="comment">//窗口处理函数</span></span><br><span class="line">wndclass<span class="variable">.cbClsExtra</span>    = <span class="number">0</span> ;<span class="comment">//窗口扩展</span></span><br><span class="line">wndclass<span class="variable">.cbWndExtra</span>    = <span class="number">0</span> ;<span class="comment">//窗口实例扩展</span></span><br><span class="line">wndclass<span class="variable">.hInstance</span>     = hModule ;<span class="comment">//实例句柄</span></span><br><span class="line">wndclass<span class="variable">.hIcon</span>         = LoadIcon (<span class="literal">NULL</span>, IDI_APPLI<span class="built_in">CATION</span>) ;<span class="comment">//窗口的最小化图标</span></span><br><span class="line">wndclass<span class="variable">.hCursor</span>       = LoadCursor (<span class="literal">NULL</span>, IDC_ARROW) ;<span class="comment">//窗口鼠标光标</span></span><br><span class="line">wndclass<span class="variable">.hbrBackground</span> = (HBRUSH) GetStockObject (WHITE_BRUSH) ;<span class="comment">//窗口背景色</span></span><br><span class="line">wndclass<span class="variable">.lpszMenuName</span>  = <span class="literal">NULL</span> ;<span class="comment">//窗口菜单</span></span><br><span class="line">wndclass<span class="variable">.lpszClassName</span> = szAppName ;<span class="comment">// 窗口类名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建自定义的窗口类时，在使用该窗口类前必须注册该窗口类</span></span><br><span class="line"><span class="keyword">if</span> (!RegisterClass (&amp;wndclass))</span><br><span class="line">&#123;</span><br><span class="line">	MessageBox (<span class="literal">NULL</span>, TEXT (<span class="string">"This program requires Windows NT!"</span>), </span><br><span class="line">		szAppName, MB_ICONERROR) ;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口用来接收消息</span></span><br><span class="line">hwnd = CreateWindow (szAppName,                  <span class="comment">// window class name</span></span><br><span class="line">	TEXT (<span class="string">"The Hello Program"</span>), <span class="comment">// window caption</span></span><br><span class="line">	WS_OVERLAPPEDWINDOW,        <span class="comment">// window style</span></span><br><span class="line">	CW_USEDEFAULT,              <span class="comment">// initial x position</span></span><br><span class="line">	CW_USEDEFAULT,              <span class="comment">// initial y position</span></span><br><span class="line">	CW_USEDEFAULT,              <span class="comment">// initial x size</span></span><br><span class="line">	CW_USEDEFAULT,              <span class="comment">// initial y size</span></span><br><span class="line">	<span class="literal">NULL</span>,                       <span class="comment">// parent window handle</span></span><br><span class="line">	<span class="literal">NULL</span>,                       <span class="comment">// window menu handle</span></span><br><span class="line">	hModule,                  <span class="comment">// program instance handle</span></span><br><span class="line">	<span class="literal">NULL</span>);                  <span class="comment">// creation parameters</span></span><br></pre></td></tr></table></figure></p>
<h1 id="0x03_Register_DBT_DEVTYP_DEVICEINTERFACE">0x03 Register DBT_DEVTYP_DEVICEINTERFACE</h1><p>　　通过上面的代码，能够捕获U盘插入的消息，但却无法捕获到其他类型的USB设备。经过调试，发现只有当pHdr-&gt;dbch_devicetype=DBT_DEVTYP_VOLUME时，才会接收到通知。所以上面的代码中用PDEV_BROADCAST_DEVICEINTERFACE结构去格式化lParam就会得到错误的dbcc_classguid和dbcc_name,而用PDEV_BROADCAST_VOLUME则可以获取正确的盘符信息（dbcv_unitmask）。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _DEV_BROADCAST_HDR &#123;</span><br><span class="line">  DWORD dbch_size<span class="comment">;</span></span><br><span class="line">  DWORD dbch_devicetype<span class="comment">;</span></span><br><span class="line">  DWORD dbch_reserved<span class="comment">;</span></span><br><span class="line">&#125; DEV_BROADCAST_HDR, *PDEV_BROADCAST_HDR<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">typedef struct _DEV_BROADCAST_VOLUME &#123;</span><br><span class="line">  DWORD dbcv_size<span class="comment">;</span></span><br><span class="line">  DWORD dbcv_devicetype<span class="comment">;</span></span><br><span class="line">  DWORD dbcv_reserved<span class="comment">;</span></span><br><span class="line">  DWORD dbcv_unitmask<span class="comment">;</span></span><br><span class="line">  WORD  dbcv_flags<span class="comment">;</span></span><br><span class="line">&#125; DEV_BROADCAST_VOLUME, *PDEV_BROADCAST_VOLUME<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">typedef struct _DEV_BROADCAST_DEVICEINTERFACE &#123;</span><br><span class="line">  DWORD dbcc_size<span class="comment">;</span></span><br><span class="line">  DWORD dbcc_devicetype<span class="comment">;</span></span><br><span class="line">  DWORD dbcc_reserved<span class="comment">;</span></span><br><span class="line">  GUID  dbcc_classguid<span class="comment">;</span></span><br><span class="line">  TCHAR dbcc_name[1]<span class="comment">;</span></span><br><span class="line">&#125; DEV_BROADCAST_DEVICEINTERFACE, *PDEV_BROADCAST_DEVICEINTERFACE<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>　　MSDN<a href="https://msdn.microsoft.com/EN-US/library/windows/desktop/aa363431.aspx" target="_blank" rel="external"><font color="blue">[RegisterDeviceNotification]</font></a>中Remarks部分说明了顶层窗口会收到basic notification，其中就包括了DBT_DEVTYP_VOLUME和DBT_DEVTYP_PORT，其他类型的通知则需要通过RegisterDeviceNotification来注册。RegisterDeviceNotification中第二个参数填入DEV_BROADCAST_DEVICEINTERFACE结构，dbcc_devicetype=DBT_DEVTYP_DEVICEINTERFACE、dbcc_classguid=GUID_DEVINTERFACE_USB_DEVICE,也可以根据需要换成他<a href="http://blog.csdn.net/jhqin/article/details/6775321" target="_blank" rel="external"><font color="blue">常用设备接口类GUID</font></a>。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">#define DBT_DEVTYP_OEM                  <span class="number">0x00000000</span>  // oem-defined device type</span><br><span class="line">#define DBT_DEVTYP_DEVNODE              <span class="number">0x00000001</span>  // devnode number</span><br><span class="line">#define DBT_DEVTYP_VOLUME               <span class="number">0x00000002</span>  // logical volume</span><br><span class="line">#define DBT_DEVTYP_PORT                 <span class="number">0x00000003</span>  // serial, parallel</span><br><span class="line">#define DBT_DEVTYP_NET                  <span class="number">0x00000004</span>  // network resource</span><br><span class="line"></span><br><span class="line">#if(WINVER &gt;= 0x040A)</span><br><span class="line">#define DBT_DEVTYP_DEVICEINTERFACE      <span class="number">0x00000005</span>  // device interface class</span><br><span class="line">#define DBT_DEVTYP_HANDLE               <span class="number">0x00000006</span>  // file system handle</span><br><span class="line"></span><br><span class="line">#if(WINVER &gt;= _WIN32_WINNT_WIN7)</span><br><span class="line">#define DBT_DEVTYP_DEVINST              <span class="number">0x00000007</span>  // device instance</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">DEV_BROADCAST_DEVICEINTERFACE NotificationFilter<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">ZeroMemory(&amp;NotificationFilter, sizeof(NotificationFilter))<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">NotificationFilter.dbcc_size = sizeof(NotificationFilter)<span class="comment">;</span></span><br><span class="line">NotificationFilter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE<span class="comment">;</span></span><br><span class="line">NotificationFilter.dbcc_reserved = 0<span class="comment">;</span></span><br><span class="line">NotificationFilter.dbcc_classguid = GUID_DEVINTERFACE_USB_DEVICE<span class="comment">;</span></span><br><span class="line">HDEVNOTIFY hDevNotify = RegisterDeviceNotification(hwnd, &amp;NotificationFilter, DEVICE_NOTIFY_WINDOW_HANDLE)<span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">UnregisterDeviceNotification(hDevNotify)<span class="comment">;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>　　修改WindowPro函数<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LRESULT CALLBACK UsbProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (message)  </span><br><span class="line">	&#123;  	</span><br><span class="line">	<span class="keyword">case</span> WM_DEVICECHANGE:  </span><br><span class="line">		<span class="keyword">if</span>(wParam == DBT_DEVICEARRIVAL) <span class="comment">//设备激活  </span></span><br><span class="line">		&#123;  </span><br><span class="line">			PDEV_BROADCAST_HDR lpdb = (PDEV_BROADCAST_HDR)lParam;</span><br><span class="line">			<span class="keyword">if</span> (lpdb-&gt;dbch_devicetype == DBT_DEVTYP_DEVICEINTERFACE) </span><br><span class="line">			&#123;</span><br><span class="line">				DEV_BROADCAST_HDR* pHdr = (DEV_BROADCAST_HDR*)lParam;</span><br><span class="line">				PDEV_BROADCAST_DEVICEINTERFACE pdinfo = (PDEV_BROADCAST_DEVICEINTERFACE)pHdr;</span><br><span class="line">				printf(<span class="string">"GUID:%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n"</span>,pdinfo-&gt;dbcc_classguid.Data1,pdinfo-&gt;dbcc_classguid.Data2,pdinfo-&gt;dbcc_classguid.Data3,pdinfo-&gt;dbcc_classguid.Data4[<span class="number">0</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">1</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">2</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">3</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">4</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">5</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">6</span>],pdinfo-&gt;dbcc_classguid.Data4[<span class="number">7</span>]);</span><br><span class="line">				printf(<span class="string">"dbcc_name:%s"</span>,pdinfo-&gt;dbcc_name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;  </span><br><span class="line">		<span class="keyword">break</span>;  </span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> DefWindowProc (hwnd, message, wParam, lParam) ;  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考资料<br><a href="http://bbs.csdn.net/topics/390158016" target="_blank" rel="external"><font color="blue">CSDN-关于u盘识别（OnDeviceChange方式）的几个问题，请教！</font></a><br><a href="http://blog.sina.com.cn/s/blog_9ffb29e101018sug.html" target="_blank" rel="external"><font color="blue">新浪博客-利用服务获取USB设备插拨事件以及获取设备硬件信息</font></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_说明">0x00 说明</h1><p>　　最先在网上copy的代码，能捕获U盘插入的消息，但不能捕获其他USB设备的消息，且无法获取U盘dbcc_name，多次询问度娘后终于找到正确的姿势，通过RegisterDeviceNotification注册DBT_DEVTYP_DEVICEINTERFACE，获取所有USB类设备的通知。</p>
<h1 id="0x01_WM_DEVICECHANGE">0x01 WM_DEVICECHANGE</h1><p>　　查询MSDN<a href="https://msdn.microsoft.com/en-us/library/aa363480(VS.85).aspx"><font color="blue">[WM_DEVICECHANGE message]</font></a>,当设备或电脑的硬件配置发生改变时，会给每一个顶层窗口发通知，窗口通过WindowPro接收这个消息。WindowPro中的wParam参数告诉我们是具体是发生了什么事件，即设备或电脑的硬件配置发生了怎样的变化;lParam参数包含了一些设备具体的信息（wParam不同，对应的lParam也有一点的变化）。如果有U盘插入（这里为什么说是U盘而不是USB设备将会在后面进行说明），wParam=DBT_DEVICEARRIVAL,lParam中包含了U盘的盘符信息。<br>　　有了上述信息，我们可自己创建一个顶层窗口来接WM_DEVICECHANGE消息。首先定义一个WindowPro函数，当message参数为WM_DEVICECHANGE，wParam参数为DBT_DEVICEARRIVAL时，即表示有U盘插入。<br>]]>
    
    </summary>
    
      <category term="Windows" scheme="http://hyjal-binbin.com/categories/Windows/"/>
    
      <category term="USB" scheme="http://hyjal-binbin.com/categories/Windows/USB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用acrobat SDK提取pdf文档内容]]></title>
    <link href="http://hyjal-binbin.com/2015/10/14/GetpdfContent/"/>
    <id>http://hyjal-binbin.com/2015/10/14/GetpdfContent/</id>
    <published>2015-10-13T16:00:00.000Z</published>
    <updated>2015-10-14T08:16:52.157Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_背景">0x00 背景</h1><p>　　HackingTeam泄漏事件影响颇大，415.77G的内容大多是邮件内容，分析起来比较麻烦，因而被大多数人忽略。网上有很多邮件分析的文章<a href="http://www.sec-un.org/analysis-on-the-hackingteam-mail-security-threat-intelligence-2.html" target="_blank" rel="external"><font color="blue">HT邮件分析</font></a>,主要是针对邮件关联进行分析，若对邮件内容进行分析则需提取邮件附件中的内容，再针对内容做进一步分析。本文背景其实与上文无关，只是借此提升逼格，下面将介绍如何利用acrobat SDK提取pdf文档内容。</p>
<h1 id="0x01_acrobat导入">0x01 acrobat导入</h1><p>　　只要安装了Adobe Acrobat，就能在其安装目录下找到acrobat.tlb，其中包含了adobe公司提供的接口,可对pdf进行各种操作<a href="http://partners.adobe.com/public/developer/en/acrobat/sdk/pdf/iac/IACOverview.pdf" target="_blank" rel="external"><font color="blue">参考文档</font></a>，使用类向导将其导入。<br>　　提取文本内容需导入CAcroApp、CAcroAVDoc、CAcroAVPageView、CAcroPDPage、CAcroPDTextSelect、CAcroHiliteList。<br><a id="more"></a></p>
<h1 id="0x02_提取文档内容">0x02 提取文档内容</h1><p>　　首先需要”打开”pdf，核心代码如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CAcroApp <span class="subst">*</span>pAcrpApp <span class="subst">=</span> <span class="literal">new</span> CAcroApp;</span><br><span class="line">COleException e;</span><br><span class="line">pAcrpApp<span class="subst">-&gt;</span>CreateDispatch(<span class="string">"AcroExch.App"</span>,<span class="subst">&amp;</span>e);</span><br><span class="line">CAcroAVDoc <span class="subst">*</span>pAvdoc <span class="subst">=</span> <span class="literal">new</span> CAcroAVDoc;</span><br><span class="line">pAvdoc<span class="subst">-&gt;</span>CreateDispatch(<span class="string">"AcroExch.AVDoc"</span>,<span class="subst">&amp;</span>e);</span><br><span class="line"><span class="comment">//打开pdf,其中PDFName为全路径</span></span><br><span class="line"><span class="keyword">if</span> (<span class="subst">!</span>pAvdoc<span class="subst">-&gt;</span>Open(PDFName,<span class="built_in">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">	printf(<span class="string">"open pdf failed"</span>);</span><br><span class="line">	<span class="attribute">...</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　打开文档后，通过pAvdoc可选择页数(默认为第一页)，创建高亮板(CAcroHiliteList),将选择页数的内容加入高亮板，然后就可以从中提取出该页的内容，核心代码如下：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">CAcroAVPageView pageView;</span><br><span class="line">CAcroPDPage page;</span><br><span class="line">CAcroPDTextSelect<span class="built_in">*</span> textSelect = new CAcroPDTextSelect;</span><br><span class="line">CAcroHiliteList<span class="built_in">*</span> hilite = new CAcroHiliteList;</span><br><span class="line">long selectionSize;</span><br><span class="line">pageView.AttachDispatch<span class="params">(pAvdoc-&gt;GetAVPageView<span class="params">()</span>,TRUE)</span>;</span><br><span class="line">	</span><br><span class="line">hilite-&gt;CreateDispatch<span class="params">(<span class="string">"AcroExch.HiliteList"</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(hilite)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置为第一页</span></span><br><span class="line">	pageView.GoTo<span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	这里是设置高亮板的大小</span><br><span class="line">	由于没有找到如何在设置高亮板前获取该页内容长度的方法，所以采用设置成极大的长度</span><br><span class="line">	如有朋友知道方法，欢迎提出相互学习</span><br><span class="line">	*/</span></span><br><span class="line">	hilite-&gt;Add<span class="params">(<span class="number">0</span>,<span class="number">4000</span>)</span>;		</span><br><span class="line">	page.AttachDispatch<span class="params">(pageView.GetPage<span class="params">()</span>, TRUE)</span>;				</span><br><span class="line">	textSelect-&gt;AttachDispatch<span class="params">(page.CreateWordHilite<span class="params">(hilite-&gt;m_lpDispatch)</span>)</span>;</span><br><span class="line"></span><br><span class="line">	pAvdoc-&gt;SetTextSelection<span class="params">(textSelect-&gt;m_lpDispatch)</span>;</span><br><span class="line"></span><br><span class="line">	selectionSize = textSelect-&gt;GetNumText<span class="params">()</span>;		</span><br><span class="line">	<span class="keyword">if</span> <span class="params">(selectionSize &amp;&amp; strText.GetLength<span class="params">()</span> &lt; <span class="number">4000</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span><span class="params">(int i = <span class="number">0</span>;i &lt; selectionSize;i ++)</span></span><br><span class="line">		&#123;</span><br><span class="line">			strText += textSelect-&gt;GetText<span class="params">(i)</span>;</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;				</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　　程序效果如下：</p>
<p><div align="center"><br><img src="/img/GetPDFConTent.png" alt="GetPDFConTent" align="center"><br></div><br>　　要完整提取出文档中的全部内容，可通过CAcroPDDoc获取pdf总页数，然后利用pageView.GoTo循环每一页，下面给出的完整工程将不包含此部分代码。<br><a href="http://download.csdn.net/detail/hyjal/9179615" target="_blank" rel="external"><font color="blue">完整工程下载</font></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_背景">0x00 背景</h1><p>　　HackingTeam泄漏事件影响颇大，415.77G的内容大多是邮件内容，分析起来比较麻烦，因而被大多数人忽略。网上有很多邮件分析的文章<a href="http://www.sec-un.org/analysis-on-the-hackingteam-mail-security-threat-intelligence-2.html"><font color = "blue">HT邮件分析</font></a>,主要是针对邮件关联进行分析，若对邮件内容进行分析则需提取邮件附件中的内容，再针对内容做进一步分析。本文背景其实与上文无关，只是借此提升逼格，下面将介绍如何利用acrobat SDK提取pdf文档内容。</p>
<h1 id="0x01_acrobat导入">0x01 acrobat导入</h1><p>　　只要安装了Adobe Acrobat，就能在其安装目录下找到acrobat.tlb，其中包含了adobe公司提供的接口,可对pdf进行各种操作<a href="http://partners.adobe.com/public/developer/en/acrobat/sdk/pdf/iac/IACOverview.pdf"><font color = "blue">参考文档</font></a>，使用类向导将其导入。<br>　　提取文本内容需导入CAcroApp、CAcroAVDoc、CAcroAVPageView、CAcroPDPage、CAcroPDTextSelect、CAcroHiliteList。<br>]]>
    
    </summary>
    
      <category term="Windows" scheme="http://hyjal-binbin.com/categories/Windows/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[windows平台下获取USB设备“身份证”]]></title>
    <link href="http://hyjal-binbin.com/2015/10/07/device-CA/"/>
    <id>http://hyjal-binbin.com/2015/10/07/device-CA/</id>
    <published>2015-10-06T16:00:00.000Z</published>
    <updated>2015-10-22T03:13:30.149Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00_写在前面">0x00 写在前面</h1><p>　　当我们将U盘插入windows主机时，会提示安装驱动，那么windows是如何判断应该安装哪个版本的驱动的呢？在这里将用到设备的身份信息，包括厂商、型号、序列号等。大概半年前做了一个关于设备检测的小工程，看了很多资料和帖子，将获取设备身份信息的方法在此记录，方便以后使用。</p>
<h1 id="0x01_USB设备有哪些身份信息">0x01 USB设备有哪些身份信息</h1><p>　　根据USB规范中的说明<a href="http://www.usb.org/developers/docs" target="_blank" rel="external"><font color="blue">USB规范官方文档</font></a>，供应商ID(VID)/产品识别码(PID)唯一标识一个设备，VID和PID都是两个字节长，其中，供应商ID（VID）由供应商向USB执行论坛申请，每个供应商的VID是唯一的，PID由供应商自行决定，理论上来说，不同的产品、相同产品的不同型号、相同型号的不同设计的产品最好采用不同的PID，以便区别相同厂家的不同设备。<a id="more"></a><br>　　在windows系统中，我们可以通过设备管理器-&gt;要查看的设备-&gt;属性-&gt;详细信息-&gt;硬件ID来查看VID/PID，如下图</p>
<p><div align="center"><br><img src="/img/hardwareID.png" width="414" height="430" alt="硬件ID" align="center"><br></div></p>
<h1 id="0x02_获取USB设备VID/PID">0x02 获取USB设备VID/PID</h1><p>　　下面将介绍枚举USB设备VID/PID的方法，后面会抽时间写一篇介绍如何通过U盘盘符获取U盘VID、PID的文章。<br>　　首先需要USB设备类GUID，设备管理器-&gt;通用串行总线控制器-&gt;随便选择一个设备-&gt;右键-&gt;属性-&gt;详细信息-&gt;设备类GUID，通用串行总线控制器的设备类GUID{36fc9e60-c465-11cf-8056-444553540000}。构造GUID，用SetupDiGetClassDevs获取设备信息结构的句柄，该结构包含了所有已安装USB设备。再调用SetupDiEnumDeviceInfo枚举设备实例，之后再调用SetupDiGetDeviceRegistryProperty即能获取硬件ID。核心代码如下：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">GUID USBGuid = &#123; <span class="number">0</span>x36fc9e60, <span class="number">0</span>xc465, <span class="number">0</span>x11cf, &#123; <span class="number">0</span>x80, <span class="number">0</span>x56, <span class="number">0</span>x44, <span class="number">0</span>x45, <span class="number">0</span>x53, <span class="number">0</span>x54, <span class="number">0</span>x00, <span class="number">0</span>x00&#125; &#125;;</span><br><span class="line">HDEVINFO hDevInfo = SetupDiGetClassDevs<span class="params">(&amp;USBGuid, NULL, NULL, DIGCF_PRESENT)</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> <span class="params">(int Device_Index = <span class="number">0</span>;; Device_Index++)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    BOOL bResualt = SetupDiEnumDeviceInfo<span class="params">(hDevInfo, Device_Index, &amp;tDevData)</span>;</span><br><span class="line">    ...</span><br><span class="line">    bResualt = SetupDiGetDeviceRegistryProperty<span class="params">(hDevInfo,</span><br><span class="line">			&amp;tDevData,</span><br><span class="line">			SPDRP_HARDWAREID,</span><br><span class="line">			NULL,</span><br><span class="line">			NULL,</span><br><span class="line">			<span class="number">0</span>,</span><br><span class="line">			&amp;RequiredSize)</span>;</span><br><span class="line">	<span class="keyword">if</span> <span class="params">(!bResualt)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="params">(GetLastError<span class="params">()</span> == ERROR_INSUFFICIENT_BUFFER)</span></span><br><span class="line">		&#123;</span><br><span class="line">			BYTE <span class="built_in">*</span>PropertBuffer = <span class="params">(BYTE*)</span>malloc<span class="params">(RequiredSize)</span>;</span><br><span class="line">			bResualt = SetupDiGetDeviceRegistryProperty<span class="params">(hDevInfo,</span><br><span class="line">				&amp;tDevData,</span><br><span class="line">				SPDRP_HARDWAREID,</span><br><span class="line">				NULL,</span><br><span class="line">				PropertBuffer,</span><br><span class="line">				RequiredSize,</span><br><span class="line">				NULL)</span>;</span><br><span class="line">			<span class="keyword">if</span> <span class="params">(bResualt)</span></span><br><span class="line">			&#123;</span><br><span class="line">				TCHAR <span class="built_in">*</span>HID = <span class="params">(TCHAR*)</span>PropertBuffer;</span><br><span class="line">				wprintf<span class="params">(L<span class="string">"%s \n"</span>, HID)</span>;</span><br><span class="line">    		&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">					free<span class="params">(PropertBuffer)</span>;</span><br><span class="line">					return FALSE;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行效果</p>
<p><div align="center"><br><img src="/img/enum.jpg" alt="Enum" align="center"><br></div><br><a href="http://download.csdn.net/detail/hyjal/9159365" target="_blank" rel="external"><font color="blue">完整工程下载</font></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00_写在前面">0x00 写在前面</h1><p>　　当我们将U盘插入windows主机时，会提示安装驱动，那么windows是如何判断应该安装哪个版本的驱动的呢？在这里将用到设备的身份信息，包括厂商、型号、序列号等。大概半年前做了一个关于设备检测的小工程，看了很多资料和帖子，将获取设备身份信息的方法在此记录，方便以后使用。</p>
<h1 id="0x01_USB设备有哪些身份信息">0x01 USB设备有哪些身份信息</h1><p>　　根据USB规范中的说明<a href="http://www.usb.org/developers/docs"><font color = "blue">USB规范官方文档</font></a>，供应商ID(VID)/产品识别码(PID)唯一标识一个设备，VID和PID都是两个字节长，其中，供应商ID（VID）由供应商向USB执行论坛申请，每个供应商的VID是唯一的，PID由供应商自行决定，理论上来说，不同的产品、相同产品的不同型号、相同型号的不同设计的产品最好采用不同的PID，以便区别相同厂家的不同设备。]]>
    
    </summary>
    
      <category term="Windows" scheme="http://hyjal-binbin.com/categories/Windows/"/>
    
      <category term="USB" scheme="http://hyjal-binbin.com/categories/Windows/USB/"/>
    
  </entry>
  
</feed>